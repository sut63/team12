// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/OMENX/app/ent/academicyear"
	"github.com/OMENX/app/ent/activities"
	"github.com/OMENX/app/ent/activitytype"
	"github.com/OMENX/app/ent/club"
	"github.com/OMENX/app/ent/clubapplication"
	"github.com/OMENX/app/ent/clubappstatus"
	"github.com/OMENX/app/ent/clubbranch"
	"github.com/OMENX/app/ent/clubtype"
	"github.com/OMENX/app/ent/complaint"
	"github.com/OMENX/app/ent/complainttype"
	"github.com/OMENX/app/ent/room"
	"github.com/OMENX/app/ent/roompurpose"
	"github.com/OMENX/app/ent/roomuse"
	"github.com/OMENX/app/ent/user"
	"github.com/OMENX/app/ent/usertype"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAcademicYear    = "AcademicYear"
	TypeActivities      = "Activities"
	TypeActivityType    = "ActivityType"
	TypeClub            = "Club"
	TypeClubBranch      = "ClubBranch"
	TypeClubType        = "ClubType"
	TypeClubappStatus   = "ClubappStatus"
	TypeClubapplication = "Clubapplication"
	TypeComplaint       = "Complaint"
	TypeComplaintType   = "ComplaintType"
	TypeRoom            = "Room"
	TypeRoompurpose     = "Roompurpose"
	TypeRoomuse         = "Roomuse"
	TypeUser            = "User"
	TypeUsertype        = "Usertype"
)

// AcademicYearMutation represents an operation that mutate the AcademicYears
// nodes in the graph.
type AcademicYearMutation struct {
	config
	op                Op
	typ               string
	id                *int
	semester          *string
	clearedFields     map[string]struct{}
	activities        map[int]struct{}
	removedactivities map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*AcademicYear, error)
}

var _ ent.Mutation = (*AcademicYearMutation)(nil)

// academicyearOption allows to manage the mutation configuration using functional options.
type academicyearOption func(*AcademicYearMutation)

// newAcademicYearMutation creates new mutation for $n.Name.
func newAcademicYearMutation(c config, op Op, opts ...academicyearOption) *AcademicYearMutation {
	m := &AcademicYearMutation{
		config:        c,
		op:            op,
		typ:           TypeAcademicYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAcademicYearID sets the id field of the mutation.
func withAcademicYearID(id int) academicyearOption {
	return func(m *AcademicYearMutation) {
		var (
			err   error
			once  sync.Once
			value *AcademicYear
		)
		m.oldValue = func(ctx context.Context) (*AcademicYear, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AcademicYear.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAcademicYear sets the old AcademicYear of the mutation.
func withAcademicYear(node *AcademicYear) academicyearOption {
	return func(m *AcademicYearMutation) {
		m.oldValue = func(context.Context) (*AcademicYear, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AcademicYearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AcademicYearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AcademicYearMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSemester sets the semester field.
func (m *AcademicYearMutation) SetSemester(s string) {
	m.semester = &s
}

// Semester returns the semester value in the mutation.
func (m *AcademicYearMutation) Semester() (r string, exists bool) {
	v := m.semester
	if v == nil {
		return
	}
	return *v, true
}

// OldSemester returns the old semester value of the AcademicYear.
// If the AcademicYear object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AcademicYearMutation) OldSemester(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemester is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemester requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemester: %w", err)
	}
	return oldValue.Semester, nil
}

// ResetSemester reset all changes of the "semester" field.
func (m *AcademicYearMutation) ResetSemester() {
	m.semester = nil
}

// AddActivityIDs adds the activities edge to Activities by ids.
func (m *AcademicYearMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// RemoveActivityIDs removes the activities edge to Activities by ids.
func (m *AcademicYearMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed ids of activities.
func (m *AcademicYearMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the activities ids in the mutation.
func (m *AcademicYearMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities reset all changes of the "activities" edge.
func (m *AcademicYearMutation) ResetActivities() {
	m.activities = nil
	m.removedactivities = nil
}

// Op returns the operation name.
func (m *AcademicYearMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AcademicYear).
func (m *AcademicYearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AcademicYearMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.semester != nil {
		fields = append(fields, academicyear.FieldSemester)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AcademicYearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case academicyear.FieldSemester:
		return m.Semester()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AcademicYearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case academicyear.FieldSemester:
		return m.OldSemester(ctx)
	}
	return nil, fmt.Errorf("unknown AcademicYear field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AcademicYearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case academicyear.FieldSemester:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemester(v)
		return nil
	}
	return fmt.Errorf("unknown AcademicYear field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AcademicYearMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AcademicYearMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AcademicYearMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AcademicYear numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AcademicYearMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AcademicYearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AcademicYearMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AcademicYear nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AcademicYearMutation) ResetField(name string) error {
	switch name {
	case academicyear.FieldSemester:
		m.ResetSemester()
		return nil
	}
	return fmt.Errorf("unknown AcademicYear field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AcademicYearMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activities != nil {
		edges = append(edges, academicyear.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AcademicYearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case academicyear.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AcademicYearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedactivities != nil {
		edges = append(edges, academicyear.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AcademicYearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case academicyear.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AcademicYearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AcademicYearMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AcademicYearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AcademicYear unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AcademicYearMutation) ResetEdge(name string) error {
	switch name {
	case academicyear.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown AcademicYear edge %s", name)
}

// ActivitiesMutation represents an operation that mutate the ActivitiesSlice
// nodes in the graph.
type ActivitiesMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	detail              *string
	starttime           *time.Time
	endtime             *time.Time
	clearedFields       map[string]struct{}
	activitytype        *int
	clearedactivitytype bool
	academicyear        *int
	clearedacademicyear bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*Activities, error)
}

var _ ent.Mutation = (*ActivitiesMutation)(nil)

// activitiesOption allows to manage the mutation configuration using functional options.
type activitiesOption func(*ActivitiesMutation)

// newActivitiesMutation creates new mutation for $n.Name.
func newActivitiesMutation(c config, op Op, opts ...activitiesOption) *ActivitiesMutation {
	m := &ActivitiesMutation{
		config:        c,
		op:            op,
		typ:           TypeActivities,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivitiesID sets the id field of the mutation.
func withActivitiesID(id int) activitiesOption {
	return func(m *ActivitiesMutation) {
		var (
			err   error
			once  sync.Once
			value *Activities
		)
		m.oldValue = func(ctx context.Context) (*Activities, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activities.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivities sets the old Activities of the mutation.
func withActivities(node *Activities) activitiesOption {
	return func(m *ActivitiesMutation) {
		m.oldValue = func(context.Context) (*Activities, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivitiesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivitiesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivitiesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ActivitiesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ActivitiesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Activities.
// If the Activities object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivitiesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ActivitiesMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the detail field.
func (m *ActivitiesMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the detail value in the mutation.
func (m *ActivitiesMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old detail value of the Activities.
// If the Activities object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivitiesMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail reset all changes of the "detail" field.
func (m *ActivitiesMutation) ResetDetail() {
	m.detail = nil
}

// SetStarttime sets the starttime field.
func (m *ActivitiesMutation) SetStarttime(t time.Time) {
	m.starttime = &t
}

// Starttime returns the starttime value in the mutation.
func (m *ActivitiesMutation) Starttime() (r time.Time, exists bool) {
	v := m.starttime
	if v == nil {
		return
	}
	return *v, true
}

// OldStarttime returns the old starttime value of the Activities.
// If the Activities object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivitiesMutation) OldStarttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStarttime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStarttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarttime: %w", err)
	}
	return oldValue.Starttime, nil
}

// ResetStarttime reset all changes of the "starttime" field.
func (m *ActivitiesMutation) ResetStarttime() {
	m.starttime = nil
}

// SetEndtime sets the endtime field.
func (m *ActivitiesMutation) SetEndtime(t time.Time) {
	m.endtime = &t
}

// Endtime returns the endtime value in the mutation.
func (m *ActivitiesMutation) Endtime() (r time.Time, exists bool) {
	v := m.endtime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndtime returns the old endtime value of the Activities.
// If the Activities object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivitiesMutation) OldEndtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndtime: %w", err)
	}
	return oldValue.Endtime, nil
}

// ResetEndtime reset all changes of the "endtime" field.
func (m *ActivitiesMutation) ResetEndtime() {
	m.endtime = nil
}

// SetActivitytypeID sets the activitytype edge to ActivityType by id.
func (m *ActivitiesMutation) SetActivitytypeID(id int) {
	m.activitytype = &id
}

// ClearActivitytype clears the activitytype edge to ActivityType.
func (m *ActivitiesMutation) ClearActivitytype() {
	m.clearedactivitytype = true
}

// ActivitytypeCleared returns if the edge activitytype was cleared.
func (m *ActivitiesMutation) ActivitytypeCleared() bool {
	return m.clearedactivitytype
}

// ActivitytypeID returns the activitytype id in the mutation.
func (m *ActivitiesMutation) ActivitytypeID() (id int, exists bool) {
	if m.activitytype != nil {
		return *m.activitytype, true
	}
	return
}

// ActivitytypeIDs returns the activitytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActivitytypeID instead. It exists only for internal usage by the builders.
func (m *ActivitiesMutation) ActivitytypeIDs() (ids []int) {
	if id := m.activitytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivitytype reset all changes of the "activitytype" edge.
func (m *ActivitiesMutation) ResetActivitytype() {
	m.activitytype = nil
	m.clearedactivitytype = false
}

// SetAcademicyearID sets the academicyear edge to AcademicYear by id.
func (m *ActivitiesMutation) SetAcademicyearID(id int) {
	m.academicyear = &id
}

// ClearAcademicyear clears the academicyear edge to AcademicYear.
func (m *ActivitiesMutation) ClearAcademicyear() {
	m.clearedacademicyear = true
}

// AcademicyearCleared returns if the edge academicyear was cleared.
func (m *ActivitiesMutation) AcademicyearCleared() bool {
	return m.clearedacademicyear
}

// AcademicyearID returns the academicyear id in the mutation.
func (m *ActivitiesMutation) AcademicyearID() (id int, exists bool) {
	if m.academicyear != nil {
		return *m.academicyear, true
	}
	return
}

// AcademicyearIDs returns the academicyear ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AcademicyearID instead. It exists only for internal usage by the builders.
func (m *ActivitiesMutation) AcademicyearIDs() (ids []int) {
	if id := m.academicyear; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAcademicyear reset all changes of the "academicyear" edge.
func (m *ActivitiesMutation) ResetAcademicyear() {
	m.academicyear = nil
	m.clearedacademicyear = false
}

// SetUserID sets the user edge to User by id.
func (m *ActivitiesMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *ActivitiesMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *ActivitiesMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *ActivitiesMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ActivitiesMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *ActivitiesMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *ActivitiesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activities).
func (m *ActivitiesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivitiesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, activities.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, activities.FieldDetail)
	}
	if m.starttime != nil {
		fields = append(fields, activities.FieldStarttime)
	}
	if m.endtime != nil {
		fields = append(fields, activities.FieldEndtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivitiesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activities.FieldName:
		return m.Name()
	case activities.FieldDetail:
		return m.Detail()
	case activities.FieldStarttime:
		return m.Starttime()
	case activities.FieldEndtime:
		return m.Endtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivitiesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activities.FieldName:
		return m.OldName(ctx)
	case activities.FieldDetail:
		return m.OldDetail(ctx)
	case activities.FieldStarttime:
		return m.OldStarttime(ctx)
	case activities.FieldEndtime:
		return m.OldEndtime(ctx)
	}
	return nil, fmt.Errorf("unknown Activities field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivitiesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activities.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activities.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case activities.FieldStarttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarttime(v)
		return nil
	case activities.FieldEndtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndtime(v)
		return nil
	}
	return fmt.Errorf("unknown Activities field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivitiesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivitiesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivitiesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activities numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivitiesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivitiesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivitiesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Activities nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivitiesMutation) ResetField(name string) error {
	switch name {
	case activities.FieldName:
		m.ResetName()
		return nil
	case activities.FieldDetail:
		m.ResetDetail()
		return nil
	case activities.FieldStarttime:
		m.ResetStarttime()
		return nil
	case activities.FieldEndtime:
		m.ResetEndtime()
		return nil
	}
	return fmt.Errorf("unknown Activities field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivitiesMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.activitytype != nil {
		edges = append(edges, activities.EdgeActivitytype)
	}
	if m.academicyear != nil {
		edges = append(edges, activities.EdgeAcademicyear)
	}
	if m.user != nil {
		edges = append(edges, activities.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivitiesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activities.EdgeActivitytype:
		if id := m.activitytype; id != nil {
			return []ent.Value{*id}
		}
	case activities.EdgeAcademicyear:
		if id := m.academicyear; id != nil {
			return []ent.Value{*id}
		}
	case activities.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivitiesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivitiesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivitiesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedactivitytype {
		edges = append(edges, activities.EdgeActivitytype)
	}
	if m.clearedacademicyear {
		edges = append(edges, activities.EdgeAcademicyear)
	}
	if m.cleareduser {
		edges = append(edges, activities.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivitiesMutation) EdgeCleared(name string) bool {
	switch name {
	case activities.EdgeActivitytype:
		return m.clearedactivitytype
	case activities.EdgeAcademicyear:
		return m.clearedacademicyear
	case activities.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivitiesMutation) ClearEdge(name string) error {
	switch name {
	case activities.EdgeActivitytype:
		m.ClearActivitytype()
		return nil
	case activities.EdgeAcademicyear:
		m.ClearAcademicyear()
		return nil
	case activities.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Activities unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivitiesMutation) ResetEdge(name string) error {
	switch name {
	case activities.EdgeActivitytype:
		m.ResetActivitytype()
		return nil
	case activities.EdgeAcademicyear:
		m.ResetAcademicyear()
		return nil
	case activities.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Activities edge %s", name)
}

// ActivityTypeMutation represents an operation that mutate the ActivityTypes
// nodes in the graph.
type ActivityTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	clearedFields     map[string]struct{}
	activities        map[int]struct{}
	removedactivities map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*ActivityType, error)
}

var _ ent.Mutation = (*ActivityTypeMutation)(nil)

// activitytypeOption allows to manage the mutation configuration using functional options.
type activitytypeOption func(*ActivityTypeMutation)

// newActivityTypeMutation creates new mutation for $n.Name.
func newActivityTypeMutation(c config, op Op, opts ...activitytypeOption) *ActivityTypeMutation {
	m := &ActivityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityTypeID sets the id field of the mutation.
func withActivityTypeID(id int) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityType
		)
		m.oldValue = func(ctx context.Context) (*ActivityType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityType sets the old ActivityType of the mutation.
func withActivityType(node *ActivityType) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		m.oldValue = func(context.Context) (*ActivityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivityTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ActivityTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ActivityTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ActivityType.
// If the ActivityType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ActivityTypeMutation) ResetName() {
	m.name = nil
}

// AddActivityIDs adds the activities edge to Activities by ids.
func (m *ActivityTypeMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// RemoveActivityIDs removes the activities edge to Activities by ids.
func (m *ActivityTypeMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed ids of activities.
func (m *ActivityTypeMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the activities ids in the mutation.
func (m *ActivityTypeMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities reset all changes of the "activities" edge.
func (m *ActivityTypeMutation) ResetActivities() {
	m.activities = nil
	m.removedactivities = nil
}

// Op returns the operation name.
func (m *ActivityTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivityType).
func (m *ActivityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivityTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, activitytype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitytype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitytype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivityTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ActivityType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivityTypeMutation) ResetField(name string) error {
	switch name {
	case activitytype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activities != nil {
		edges = append(edges, activitytype.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedactivities != nil {
		edges = append(edges, activitytype.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivityTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivityTypeMutation) ResetEdge(name string) error {
	switch name {
	case activitytype.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown ActivityType edge %s", name)
}

// ClubMutation represents an operation that mutate the Clubs
// nodes in the graph.
type ClubMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	purpose                 *string
	foundingdate            *time.Time
	clearedFields           map[string]struct{}
	user                    *int
	cleareduser             bool
	clubtype                *int
	clearedclubtype         bool
	clubbranch              *int
	clearedclubbranch       bool
	clubapplication         map[int]struct{}
	removedclubapplication  map[int]struct{}
	_ClubToComplaint        map[int]struct{}
	removed_ClubToComplaint map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Club, error)
}

var _ ent.Mutation = (*ClubMutation)(nil)

// clubOption allows to manage the mutation configuration using functional options.
type clubOption func(*ClubMutation)

// newClubMutation creates new mutation for $n.Name.
func newClubMutation(c config, op Op, opts ...clubOption) *ClubMutation {
	m := &ClubMutation{
		config:        c,
		op:            op,
		typ:           TypeClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubID sets the id field of the mutation.
func withClubID(id int) clubOption {
	return func(m *ClubMutation) {
		var (
			err   error
			once  sync.Once
			value *Club
		)
		m.oldValue = func(ctx context.Context) (*Club, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Club.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClub sets the old Club of the mutation.
func withClub(node *Club) clubOption {
	return func(m *ClubMutation) {
		m.oldValue = func(context.Context) (*Club, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ClubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ClubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Club.
// If the Club object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ClubMutation) ResetName() {
	m.name = nil
}

// SetPurpose sets the purpose field.
func (m *ClubMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the purpose value in the mutation.
func (m *ClubMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old purpose value of the Club.
// If the Club object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurpose is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose reset all changes of the "purpose" field.
func (m *ClubMutation) ResetPurpose() {
	m.purpose = nil
}

// SetFoundingdate sets the foundingdate field.
func (m *ClubMutation) SetFoundingdate(t time.Time) {
	m.foundingdate = &t
}

// Foundingdate returns the foundingdate value in the mutation.
func (m *ClubMutation) Foundingdate() (r time.Time, exists bool) {
	v := m.foundingdate
	if v == nil {
		return
	}
	return *v, true
}

// OldFoundingdate returns the old foundingdate value of the Club.
// If the Club object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubMutation) OldFoundingdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFoundingdate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFoundingdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoundingdate: %w", err)
	}
	return oldValue.Foundingdate, nil
}

// ResetFoundingdate reset all changes of the "foundingdate" field.
func (m *ClubMutation) ResetFoundingdate() {
	m.foundingdate = nil
}

// SetUserID sets the user edge to User by id.
func (m *ClubMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *ClubMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *ClubMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *ClubMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *ClubMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetClubtypeID sets the clubtype edge to ClubType by id.
func (m *ClubMutation) SetClubtypeID(id int) {
	m.clubtype = &id
}

// ClearClubtype clears the clubtype edge to ClubType.
func (m *ClubMutation) ClearClubtype() {
	m.clearedclubtype = true
}

// ClubtypeCleared returns if the edge clubtype was cleared.
func (m *ClubMutation) ClubtypeCleared() bool {
	return m.clearedclubtype
}

// ClubtypeID returns the clubtype id in the mutation.
func (m *ClubMutation) ClubtypeID() (id int, exists bool) {
	if m.clubtype != nil {
		return *m.clubtype, true
	}
	return
}

// ClubtypeIDs returns the clubtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClubtypeID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) ClubtypeIDs() (ids []int) {
	if id := m.clubtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClubtype reset all changes of the "clubtype" edge.
func (m *ClubMutation) ResetClubtype() {
	m.clubtype = nil
	m.clearedclubtype = false
}

// SetClubbranchID sets the clubbranch edge to ClubBranch by id.
func (m *ClubMutation) SetClubbranchID(id int) {
	m.clubbranch = &id
}

// ClearClubbranch clears the clubbranch edge to ClubBranch.
func (m *ClubMutation) ClearClubbranch() {
	m.clearedclubbranch = true
}

// ClubbranchCleared returns if the edge clubbranch was cleared.
func (m *ClubMutation) ClubbranchCleared() bool {
	return m.clearedclubbranch
}

// ClubbranchID returns the clubbranch id in the mutation.
func (m *ClubMutation) ClubbranchID() (id int, exists bool) {
	if m.clubbranch != nil {
		return *m.clubbranch, true
	}
	return
}

// ClubbranchIDs returns the clubbranch ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClubbranchID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) ClubbranchIDs() (ids []int) {
	if id := m.clubbranch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClubbranch reset all changes of the "clubbranch" edge.
func (m *ClubMutation) ResetClubbranch() {
	m.clubbranch = nil
	m.clearedclubbranch = false
}

// AddClubapplicationIDs adds the clubapplication edge to Clubapplication by ids.
func (m *ClubMutation) AddClubapplicationIDs(ids ...int) {
	if m.clubapplication == nil {
		m.clubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.clubapplication[ids[i]] = struct{}{}
	}
}

// RemoveClubapplicationIDs removes the clubapplication edge to Clubapplication by ids.
func (m *ClubMutation) RemoveClubapplicationIDs(ids ...int) {
	if m.removedclubapplication == nil {
		m.removedclubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclubapplication[ids[i]] = struct{}{}
	}
}

// RemovedClubapplication returns the removed ids of clubapplication.
func (m *ClubMutation) RemovedClubapplicationIDs() (ids []int) {
	for id := range m.removedclubapplication {
		ids = append(ids, id)
	}
	return
}

// ClubapplicationIDs returns the clubapplication ids in the mutation.
func (m *ClubMutation) ClubapplicationIDs() (ids []int) {
	for id := range m.clubapplication {
		ids = append(ids, id)
	}
	return
}

// ResetClubapplication reset all changes of the "clubapplication" edge.
func (m *ClubMutation) ResetClubapplication() {
	m.clubapplication = nil
	m.removedclubapplication = nil
}

// AddClubToComplaintIDs adds the ClubToComplaint edge to Complaint by ids.
func (m *ClubMutation) AddClubToComplaintIDs(ids ...int) {
	if m._ClubToComplaint == nil {
		m._ClubToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m._ClubToComplaint[ids[i]] = struct{}{}
	}
}

// RemoveClubToComplaintIDs removes the ClubToComplaint edge to Complaint by ids.
func (m *ClubMutation) RemoveClubToComplaintIDs(ids ...int) {
	if m.removed_ClubToComplaint == nil {
		m.removed_ClubToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ClubToComplaint[ids[i]] = struct{}{}
	}
}

// RemovedClubToComplaint returns the removed ids of ClubToComplaint.
func (m *ClubMutation) RemovedClubToComplaintIDs() (ids []int) {
	for id := range m.removed_ClubToComplaint {
		ids = append(ids, id)
	}
	return
}

// ClubToComplaintIDs returns the ClubToComplaint ids in the mutation.
func (m *ClubMutation) ClubToComplaintIDs() (ids []int) {
	for id := range m._ClubToComplaint {
		ids = append(ids, id)
	}
	return
}

// ResetClubToComplaint reset all changes of the "ClubToComplaint" edge.
func (m *ClubMutation) ResetClubToComplaint() {
	m._ClubToComplaint = nil
	m.removed_ClubToComplaint = nil
}

// Op returns the operation name.
func (m *ClubMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Club).
func (m *ClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClubMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, club.FieldName)
	}
	if m.purpose != nil {
		fields = append(fields, club.FieldPurpose)
	}
	if m.foundingdate != nil {
		fields = append(fields, club.FieldFoundingdate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case club.FieldName:
		return m.Name()
	case club.FieldPurpose:
		return m.Purpose()
	case club.FieldFoundingdate:
		return m.Foundingdate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case club.FieldName:
		return m.OldName(ctx)
	case club.FieldPurpose:
		return m.OldPurpose(ctx)
	case club.FieldFoundingdate:
		return m.OldFoundingdate(ctx)
	}
	return nil, fmt.Errorf("unknown Club field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case club.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case club.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	case club.FieldFoundingdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoundingdate(v)
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Club numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClubMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Club nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClubMutation) ResetField(name string) error {
	switch name {
	case club.FieldName:
		m.ResetName()
		return nil
	case club.FieldPurpose:
		m.ResetPurpose()
		return nil
	case club.FieldFoundingdate:
		m.ResetFoundingdate()
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, club.EdgeUser)
	}
	if m.clubtype != nil {
		edges = append(edges, club.EdgeClubtype)
	}
	if m.clubbranch != nil {
		edges = append(edges, club.EdgeClubbranch)
	}
	if m.clubapplication != nil {
		edges = append(edges, club.EdgeClubapplication)
	}
	if m._ClubToComplaint != nil {
		edges = append(edges, club.EdgeClubToComplaint)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeClubtype:
		if id := m.clubtype; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeClubbranch:
		if id := m.clubbranch; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.clubapplication))
		for id := range m.clubapplication {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeClubToComplaint:
		ids := make([]ent.Value, 0, len(m._ClubToComplaint))
		for id := range m._ClubToComplaint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedclubapplication != nil {
		edges = append(edges, club.EdgeClubapplication)
	}
	if m.removed_ClubToComplaint != nil {
		edges = append(edges, club.EdgeClubToComplaint)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.removedclubapplication))
		for id := range m.removedclubapplication {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeClubToComplaint:
		ids := make([]ent.Value, 0, len(m.removed_ClubToComplaint))
		for id := range m.removed_ClubToComplaint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, club.EdgeUser)
	}
	if m.clearedclubtype {
		edges = append(edges, club.EdgeClubtype)
	}
	if m.clearedclubbranch {
		edges = append(edges, club.EdgeClubbranch)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClubMutation) EdgeCleared(name string) bool {
	switch name {
	case club.EdgeUser:
		return m.cleareduser
	case club.EdgeClubtype:
		return m.clearedclubtype
	case club.EdgeClubbranch:
		return m.clearedclubbranch
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClubMutation) ClearEdge(name string) error {
	switch name {
	case club.EdgeUser:
		m.ClearUser()
		return nil
	case club.EdgeClubtype:
		m.ClearClubtype()
		return nil
	case club.EdgeClubbranch:
		m.ClearClubbranch()
		return nil
	}
	return fmt.Errorf("unknown Club unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClubMutation) ResetEdge(name string) error {
	switch name {
	case club.EdgeUser:
		m.ResetUser()
		return nil
	case club.EdgeClubtype:
		m.ResetClubtype()
		return nil
	case club.EdgeClubbranch:
		m.ResetClubbranch()
		return nil
	case club.EdgeClubapplication:
		m.ResetClubapplication()
		return nil
	case club.EdgeClubToComplaint:
		m.ResetClubToComplaint()
		return nil
	}
	return fmt.Errorf("unknown Club edge %s", name)
}

// ClubBranchMutation represents an operation that mutate the ClubBranches
// nodes in the graph.
type ClubBranchMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	club          map[int]struct{}
	removedclub   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*ClubBranch, error)
}

var _ ent.Mutation = (*ClubBranchMutation)(nil)

// clubbranchOption allows to manage the mutation configuration using functional options.
type clubbranchOption func(*ClubBranchMutation)

// newClubBranchMutation creates new mutation for $n.Name.
func newClubBranchMutation(c config, op Op, opts ...clubbranchOption) *ClubBranchMutation {
	m := &ClubBranchMutation{
		config:        c,
		op:            op,
		typ:           TypeClubBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubBranchID sets the id field of the mutation.
func withClubBranchID(id int) clubbranchOption {
	return func(m *ClubBranchMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubBranch
		)
		m.oldValue = func(ctx context.Context) (*ClubBranch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubBranch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubBranch sets the old ClubBranch of the mutation.
func withClubBranch(node *ClubBranch) clubbranchOption {
	return func(m *ClubBranchMutation) {
		m.oldValue = func(context.Context) (*ClubBranch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubBranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubBranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClubBranchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ClubBranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ClubBranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ClubBranch.
// If the ClubBranch object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubBranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ClubBranchMutation) ResetName() {
	m.name = nil
}

// AddClubIDs adds the club edge to Club by ids.
func (m *ClubBranchMutation) AddClubIDs(ids ...int) {
	if m.club == nil {
		m.club = make(map[int]struct{})
	}
	for i := range ids {
		m.club[ids[i]] = struct{}{}
	}
}

// RemoveClubIDs removes the club edge to Club by ids.
func (m *ClubBranchMutation) RemoveClubIDs(ids ...int) {
	if m.removedclub == nil {
		m.removedclub = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclub[ids[i]] = struct{}{}
	}
}

// RemovedClub returns the removed ids of club.
func (m *ClubBranchMutation) RemovedClubIDs() (ids []int) {
	for id := range m.removedclub {
		ids = append(ids, id)
	}
	return
}

// ClubIDs returns the club ids in the mutation.
func (m *ClubBranchMutation) ClubIDs() (ids []int) {
	for id := range m.club {
		ids = append(ids, id)
	}
	return
}

// ResetClub reset all changes of the "club" edge.
func (m *ClubBranchMutation) ResetClub() {
	m.club = nil
	m.removedclub = nil
}

// Op returns the operation name.
func (m *ClubBranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClubBranch).
func (m *ClubBranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClubBranchMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, clubbranch.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClubBranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubbranch.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClubBranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubbranch.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ClubBranch field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubBranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubbranch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ClubBranch field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClubBranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClubBranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubBranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubBranch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClubBranchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClubBranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubBranchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClubBranch nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClubBranchMutation) ResetField(name string) error {
	switch name {
	case clubbranch.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ClubBranch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClubBranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.club != nil {
		edges = append(edges, clubbranch.EdgeClub)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClubBranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubbranch.EdgeClub:
		ids := make([]ent.Value, 0, len(m.club))
		for id := range m.club {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClubBranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclub != nil {
		edges = append(edges, clubbranch.EdgeClub)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClubBranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clubbranch.EdgeClub:
		ids := make([]ent.Value, 0, len(m.removedclub))
		for id := range m.removedclub {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClubBranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClubBranchMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClubBranchMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubBranch unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClubBranchMutation) ResetEdge(name string) error {
	switch name {
	case clubbranch.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown ClubBranch edge %s", name)
}

// ClubTypeMutation represents an operation that mutate the ClubTypes
// nodes in the graph.
type ClubTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	club          map[int]struct{}
	removedclub   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*ClubType, error)
}

var _ ent.Mutation = (*ClubTypeMutation)(nil)

// clubtypeOption allows to manage the mutation configuration using functional options.
type clubtypeOption func(*ClubTypeMutation)

// newClubTypeMutation creates new mutation for $n.Name.
func newClubTypeMutation(c config, op Op, opts ...clubtypeOption) *ClubTypeMutation {
	m := &ClubTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeClubType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubTypeID sets the id field of the mutation.
func withClubTypeID(id int) clubtypeOption {
	return func(m *ClubTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubType
		)
		m.oldValue = func(ctx context.Context) (*ClubType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubType sets the old ClubType of the mutation.
func withClubType(node *ClubType) clubtypeOption {
	return func(m *ClubTypeMutation) {
		m.oldValue = func(context.Context) (*ClubType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClubTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ClubTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ClubTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ClubType.
// If the ClubType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ClubTypeMutation) ResetName() {
	m.name = nil
}

// AddClubIDs adds the club edge to Club by ids.
func (m *ClubTypeMutation) AddClubIDs(ids ...int) {
	if m.club == nil {
		m.club = make(map[int]struct{})
	}
	for i := range ids {
		m.club[ids[i]] = struct{}{}
	}
}

// RemoveClubIDs removes the club edge to Club by ids.
func (m *ClubTypeMutation) RemoveClubIDs(ids ...int) {
	if m.removedclub == nil {
		m.removedclub = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclub[ids[i]] = struct{}{}
	}
}

// RemovedClub returns the removed ids of club.
func (m *ClubTypeMutation) RemovedClubIDs() (ids []int) {
	for id := range m.removedclub {
		ids = append(ids, id)
	}
	return
}

// ClubIDs returns the club ids in the mutation.
func (m *ClubTypeMutation) ClubIDs() (ids []int) {
	for id := range m.club {
		ids = append(ids, id)
	}
	return
}

// ResetClub reset all changes of the "club" edge.
func (m *ClubTypeMutation) ResetClub() {
	m.club = nil
	m.removedclub = nil
}

// Op returns the operation name.
func (m *ClubTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClubType).
func (m *ClubTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClubTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, clubtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClubTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClubTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ClubType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ClubType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClubTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClubTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClubTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClubTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClubType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClubTypeMutation) ResetField(name string) error {
	switch name {
	case clubtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ClubType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClubTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.club != nil {
		edges = append(edges, clubtype.EdgeClub)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClubTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubtype.EdgeClub:
		ids := make([]ent.Value, 0, len(m.club))
		for id := range m.club {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClubTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclub != nil {
		edges = append(edges, clubtype.EdgeClub)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClubTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clubtype.EdgeClub:
		ids := make([]ent.Value, 0, len(m.removedclub))
		for id := range m.removedclub {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClubTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClubTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClubTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClubTypeMutation) ResetEdge(name string) error {
	switch name {
	case clubtype.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown ClubType edge %s", name)
}

// ClubappStatusMutation represents an operation that mutate the ClubappStatusSlice
// nodes in the graph.
type ClubappStatusMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	apply_status           *string
	clearedFields          map[string]struct{}
	clubapplication        map[int]struct{}
	removedclubapplication map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*ClubappStatus, error)
}

var _ ent.Mutation = (*ClubappStatusMutation)(nil)

// clubappstatusOption allows to manage the mutation configuration using functional options.
type clubappstatusOption func(*ClubappStatusMutation)

// newClubappStatusMutation creates new mutation for $n.Name.
func newClubappStatusMutation(c config, op Op, opts ...clubappstatusOption) *ClubappStatusMutation {
	m := &ClubappStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeClubappStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubappStatusID sets the id field of the mutation.
func withClubappStatusID(id int) clubappstatusOption {
	return func(m *ClubappStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubappStatus
		)
		m.oldValue = func(ctx context.Context) (*ClubappStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubappStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubappStatus sets the old ClubappStatus of the mutation.
func withClubappStatus(node *ClubappStatus) clubappstatusOption {
	return func(m *ClubappStatusMutation) {
		m.oldValue = func(context.Context) (*ClubappStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubappStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubappStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClubappStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetApplyStatus sets the apply_status field.
func (m *ClubappStatusMutation) SetApplyStatus(s string) {
	m.apply_status = &s
}

// ApplyStatus returns the apply_status value in the mutation.
func (m *ClubappStatusMutation) ApplyStatus() (r string, exists bool) {
	v := m.apply_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyStatus returns the old apply_status value of the ClubappStatus.
// If the ClubappStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubappStatusMutation) OldApplyStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyStatus: %w", err)
	}
	return oldValue.ApplyStatus, nil
}

// ResetApplyStatus reset all changes of the "apply_status" field.
func (m *ClubappStatusMutation) ResetApplyStatus() {
	m.apply_status = nil
}

// AddClubapplicationIDs adds the clubapplication edge to Clubapplication by ids.
func (m *ClubappStatusMutation) AddClubapplicationIDs(ids ...int) {
	if m.clubapplication == nil {
		m.clubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.clubapplication[ids[i]] = struct{}{}
	}
}

// RemoveClubapplicationIDs removes the clubapplication edge to Clubapplication by ids.
func (m *ClubappStatusMutation) RemoveClubapplicationIDs(ids ...int) {
	if m.removedclubapplication == nil {
		m.removedclubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclubapplication[ids[i]] = struct{}{}
	}
}

// RemovedClubapplication returns the removed ids of clubapplication.
func (m *ClubappStatusMutation) RemovedClubapplicationIDs() (ids []int) {
	for id := range m.removedclubapplication {
		ids = append(ids, id)
	}
	return
}

// ClubapplicationIDs returns the clubapplication ids in the mutation.
func (m *ClubappStatusMutation) ClubapplicationIDs() (ids []int) {
	for id := range m.clubapplication {
		ids = append(ids, id)
	}
	return
}

// ResetClubapplication reset all changes of the "clubapplication" edge.
func (m *ClubappStatusMutation) ResetClubapplication() {
	m.clubapplication = nil
	m.removedclubapplication = nil
}

// Op returns the operation name.
func (m *ClubappStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClubappStatus).
func (m *ClubappStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClubappStatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.apply_status != nil {
		fields = append(fields, clubappstatus.FieldApplyStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClubappStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubappstatus.FieldApplyStatus:
		return m.ApplyStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClubappStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubappstatus.FieldApplyStatus:
		return m.OldApplyStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ClubappStatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubappStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubappstatus.FieldApplyStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ClubappStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClubappStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClubappStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubappStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubappStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClubappStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClubappStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubappStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClubappStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClubappStatusMutation) ResetField(name string) error {
	switch name {
	case clubappstatus.FieldApplyStatus:
		m.ResetApplyStatus()
		return nil
	}
	return fmt.Errorf("unknown ClubappStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClubappStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clubapplication != nil {
		edges = append(edges, clubappstatus.EdgeClubapplication)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClubappStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubappstatus.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.clubapplication))
		for id := range m.clubapplication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClubappStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclubapplication != nil {
		edges = append(edges, clubappstatus.EdgeClubapplication)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClubappStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clubappstatus.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.removedclubapplication))
		for id := range m.removedclubapplication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClubappStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClubappStatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClubappStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubappStatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClubappStatusMutation) ResetEdge(name string) error {
	switch name {
	case clubappstatus.EdgeClubapplication:
		m.ResetClubapplication()
		return nil
	}
	return fmt.Errorf("unknown ClubappStatus edge %s", name)
}

// ClubapplicationMutation represents an operation that mutate the Clubapplications
// nodes in the graph.
type ClubapplicationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	applyname            *string
	contact              *string
	reason               *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	owner                *int
	clearedowner         bool
	clubappstatus        *int
	clearedclubappstatus bool
	club                 *int
	clearedclub          bool
	done                 bool
	oldValue             func(context.Context) (*Clubapplication, error)
}

var _ ent.Mutation = (*ClubapplicationMutation)(nil)

// clubapplicationOption allows to manage the mutation configuration using functional options.
type clubapplicationOption func(*ClubapplicationMutation)

// newClubapplicationMutation creates new mutation for $n.Name.
func newClubapplicationMutation(c config, op Op, opts ...clubapplicationOption) *ClubapplicationMutation {
	m := &ClubapplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeClubapplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubapplicationID sets the id field of the mutation.
func withClubapplicationID(id int) clubapplicationOption {
	return func(m *ClubapplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Clubapplication
		)
		m.oldValue = func(ctx context.Context) (*Clubapplication, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clubapplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubapplication sets the old Clubapplication of the mutation.
func withClubapplication(node *Clubapplication) clubapplicationOption {
	return func(m *ClubapplicationMutation) {
		m.oldValue = func(context.Context) (*Clubapplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubapplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubapplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClubapplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetApplyname sets the applyname field.
func (m *ClubapplicationMutation) SetApplyname(s string) {
	m.applyname = &s
}

// Applyname returns the applyname value in the mutation.
func (m *ClubapplicationMutation) Applyname() (r string, exists bool) {
	v := m.applyname
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyname returns the old applyname value of the Clubapplication.
// If the Clubapplication object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubapplicationMutation) OldApplyname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyname: %w", err)
	}
	return oldValue.Applyname, nil
}

// ResetApplyname reset all changes of the "applyname" field.
func (m *ClubapplicationMutation) ResetApplyname() {
	m.applyname = nil
}

// SetContact sets the contact field.
func (m *ClubapplicationMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the contact value in the mutation.
func (m *ClubapplicationMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old contact value of the Clubapplication.
// If the Clubapplication object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubapplicationMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContact is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ResetContact reset all changes of the "contact" field.
func (m *ClubapplicationMutation) ResetContact() {
	m.contact = nil
}

// SetReason sets the reason field.
func (m *ClubapplicationMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the reason value in the mutation.
func (m *ClubapplicationMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old reason value of the Clubapplication.
// If the Clubapplication object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubapplicationMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason reset all changes of the "reason" field.
func (m *ClubapplicationMutation) ResetReason() {
	m.reason = nil
}

// SetCreatedAt sets the created_at field.
func (m *ClubapplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ClubapplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Clubapplication.
// If the Clubapplication object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClubapplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ClubapplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *ClubapplicationMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *ClubapplicationMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *ClubapplicationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *ClubapplicationMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ClubapplicationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *ClubapplicationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetClubappstatusID sets the clubappstatus edge to ClubappStatus by id.
func (m *ClubapplicationMutation) SetClubappstatusID(id int) {
	m.clubappstatus = &id
}

// ClearClubappstatus clears the clubappstatus edge to ClubappStatus.
func (m *ClubapplicationMutation) ClearClubappstatus() {
	m.clearedclubappstatus = true
}

// ClubappstatusCleared returns if the edge clubappstatus was cleared.
func (m *ClubapplicationMutation) ClubappstatusCleared() bool {
	return m.clearedclubappstatus
}

// ClubappstatusID returns the clubappstatus id in the mutation.
func (m *ClubapplicationMutation) ClubappstatusID() (id int, exists bool) {
	if m.clubappstatus != nil {
		return *m.clubappstatus, true
	}
	return
}

// ClubappstatusIDs returns the clubappstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClubappstatusID instead. It exists only for internal usage by the builders.
func (m *ClubapplicationMutation) ClubappstatusIDs() (ids []int) {
	if id := m.clubappstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClubappstatus reset all changes of the "clubappstatus" edge.
func (m *ClubapplicationMutation) ResetClubappstatus() {
	m.clubappstatus = nil
	m.clearedclubappstatus = false
}

// SetClubID sets the club edge to Club by id.
func (m *ClubapplicationMutation) SetClubID(id int) {
	m.club = &id
}

// ClearClub clears the club edge to Club.
func (m *ClubapplicationMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared returns if the edge club was cleared.
func (m *ClubapplicationMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubID returns the club id in the mutation.
func (m *ClubapplicationMutation) ClubID() (id int, exists bool) {
	if m.club != nil {
		return *m.club, true
	}
	return
}

// ClubIDs returns the club ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ClubapplicationMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub reset all changes of the "club" edge.
func (m *ClubapplicationMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// Op returns the operation name.
func (m *ClubapplicationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Clubapplication).
func (m *ClubapplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClubapplicationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.applyname != nil {
		fields = append(fields, clubapplication.FieldApplyname)
	}
	if m.contact != nil {
		fields = append(fields, clubapplication.FieldContact)
	}
	if m.reason != nil {
		fields = append(fields, clubapplication.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, clubapplication.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClubapplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubapplication.FieldApplyname:
		return m.Applyname()
	case clubapplication.FieldContact:
		return m.Contact()
	case clubapplication.FieldReason:
		return m.Reason()
	case clubapplication.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClubapplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubapplication.FieldApplyname:
		return m.OldApplyname(ctx)
	case clubapplication.FieldContact:
		return m.OldContact(ctx)
	case clubapplication.FieldReason:
		return m.OldReason(ctx)
	case clubapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Clubapplication field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubapplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubapplication.FieldApplyname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyname(v)
		return nil
	case clubapplication.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case clubapplication.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case clubapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Clubapplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClubapplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClubapplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClubapplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Clubapplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClubapplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClubapplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubapplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Clubapplication nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClubapplicationMutation) ResetField(name string) error {
	switch name {
	case clubapplication.FieldApplyname:
		m.ResetApplyname()
		return nil
	case clubapplication.FieldContact:
		m.ResetContact()
		return nil
	case clubapplication.FieldReason:
		m.ResetReason()
		return nil
	case clubapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Clubapplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClubapplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, clubapplication.EdgeOwner)
	}
	if m.clubappstatus != nil {
		edges = append(edges, clubapplication.EdgeClubappstatus)
	}
	if m.club != nil {
		edges = append(edges, clubapplication.EdgeClub)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClubapplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubapplication.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case clubapplication.EdgeClubappstatus:
		if id := m.clubappstatus; id != nil {
			return []ent.Value{*id}
		}
	case clubapplication.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClubapplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClubapplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClubapplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, clubapplication.EdgeOwner)
	}
	if m.clearedclubappstatus {
		edges = append(edges, clubapplication.EdgeClubappstatus)
	}
	if m.clearedclub {
		edges = append(edges, clubapplication.EdgeClub)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClubapplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case clubapplication.EdgeOwner:
		return m.clearedowner
	case clubapplication.EdgeClubappstatus:
		return m.clearedclubappstatus
	case clubapplication.EdgeClub:
		return m.clearedclub
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClubapplicationMutation) ClearEdge(name string) error {
	switch name {
	case clubapplication.EdgeOwner:
		m.ClearOwner()
		return nil
	case clubapplication.EdgeClubappstatus:
		m.ClearClubappstatus()
		return nil
	case clubapplication.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown Clubapplication unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClubapplicationMutation) ResetEdge(name string) error {
	switch name {
	case clubapplication.EdgeOwner:
		m.ResetOwner()
		return nil
	case clubapplication.EdgeClubappstatus:
		m.ResetClubappstatus()
		return nil
	case clubapplication.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown Clubapplication edge %s", name)
}

// ComplaintMutation represents an operation that mutate the Complaints
// nodes in the graph.
type ComplaintMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	info                             *string
	date                             *time.Time
	clearedFields                    map[string]struct{}
	_ComplaintToUser                 *int
	cleared_ComplaintToUser          bool
	_ComplaintToComplaintType        *int
	cleared_ComplaintToComplaintType bool
	_ComplaintToClub                 *int
	cleared_ComplaintToClub          bool
	done                             bool
	oldValue                         func(context.Context) (*Complaint, error)
}

var _ ent.Mutation = (*ComplaintMutation)(nil)

// complaintOption allows to manage the mutation configuration using functional options.
type complaintOption func(*ComplaintMutation)

// newComplaintMutation creates new mutation for $n.Name.
func newComplaintMutation(c config, op Op, opts ...complaintOption) *ComplaintMutation {
	m := &ComplaintMutation{
		config:        c,
		op:            op,
		typ:           TypeComplaint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComplaintID sets the id field of the mutation.
func withComplaintID(id int) complaintOption {
	return func(m *ComplaintMutation) {
		var (
			err   error
			once  sync.Once
			value *Complaint
		)
		m.oldValue = func(ctx context.Context) (*Complaint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Complaint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComplaint sets the old Complaint of the mutation.
func withComplaint(node *Complaint) complaintOption {
	return func(m *ComplaintMutation) {
		m.oldValue = func(context.Context) (*Complaint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComplaintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComplaintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ComplaintMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInfo sets the info field.
func (m *ComplaintMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the info value in the mutation.
func (m *ComplaintMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old info value of the Complaint.
// If the Complaint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComplaintMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo reset all changes of the "info" field.
func (m *ComplaintMutation) ResetInfo() {
	m.info = nil
}

// SetDate sets the date field.
func (m *ComplaintMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the date value in the mutation.
func (m *ComplaintMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Complaint.
// If the Complaint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComplaintMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "date" field.
func (m *ComplaintMutation) ResetDate() {
	m.date = nil
}

// SetComplaintToUserID sets the ComplaintToUser edge to User by id.
func (m *ComplaintMutation) SetComplaintToUserID(id int) {
	m._ComplaintToUser = &id
}

// ClearComplaintToUser clears the ComplaintToUser edge to User.
func (m *ComplaintMutation) ClearComplaintToUser() {
	m.cleared_ComplaintToUser = true
}

// ComplaintToUserCleared returns if the edge ComplaintToUser was cleared.
func (m *ComplaintMutation) ComplaintToUserCleared() bool {
	return m.cleared_ComplaintToUser
}

// ComplaintToUserID returns the ComplaintToUser id in the mutation.
func (m *ComplaintMutation) ComplaintToUserID() (id int, exists bool) {
	if m._ComplaintToUser != nil {
		return *m._ComplaintToUser, true
	}
	return
}

// ComplaintToUserIDs returns the ComplaintToUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ComplaintToUserID instead. It exists only for internal usage by the builders.
func (m *ComplaintMutation) ComplaintToUserIDs() (ids []int) {
	if id := m._ComplaintToUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComplaintToUser reset all changes of the "ComplaintToUser" edge.
func (m *ComplaintMutation) ResetComplaintToUser() {
	m._ComplaintToUser = nil
	m.cleared_ComplaintToUser = false
}

// SetComplaintToComplaintTypeID sets the ComplaintToComplaintType edge to ComplaintType by id.
func (m *ComplaintMutation) SetComplaintToComplaintTypeID(id int) {
	m._ComplaintToComplaintType = &id
}

// ClearComplaintToComplaintType clears the ComplaintToComplaintType edge to ComplaintType.
func (m *ComplaintMutation) ClearComplaintToComplaintType() {
	m.cleared_ComplaintToComplaintType = true
}

// ComplaintToComplaintTypeCleared returns if the edge ComplaintToComplaintType was cleared.
func (m *ComplaintMutation) ComplaintToComplaintTypeCleared() bool {
	return m.cleared_ComplaintToComplaintType
}

// ComplaintToComplaintTypeID returns the ComplaintToComplaintType id in the mutation.
func (m *ComplaintMutation) ComplaintToComplaintTypeID() (id int, exists bool) {
	if m._ComplaintToComplaintType != nil {
		return *m._ComplaintToComplaintType, true
	}
	return
}

// ComplaintToComplaintTypeIDs returns the ComplaintToComplaintType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ComplaintToComplaintTypeID instead. It exists only for internal usage by the builders.
func (m *ComplaintMutation) ComplaintToComplaintTypeIDs() (ids []int) {
	if id := m._ComplaintToComplaintType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComplaintToComplaintType reset all changes of the "ComplaintToComplaintType" edge.
func (m *ComplaintMutation) ResetComplaintToComplaintType() {
	m._ComplaintToComplaintType = nil
	m.cleared_ComplaintToComplaintType = false
}

// SetComplaintToClubID sets the ComplaintToClub edge to Club by id.
func (m *ComplaintMutation) SetComplaintToClubID(id int) {
	m._ComplaintToClub = &id
}

// ClearComplaintToClub clears the ComplaintToClub edge to Club.
func (m *ComplaintMutation) ClearComplaintToClub() {
	m.cleared_ComplaintToClub = true
}

// ComplaintToClubCleared returns if the edge ComplaintToClub was cleared.
func (m *ComplaintMutation) ComplaintToClubCleared() bool {
	return m.cleared_ComplaintToClub
}

// ComplaintToClubID returns the ComplaintToClub id in the mutation.
func (m *ComplaintMutation) ComplaintToClubID() (id int, exists bool) {
	if m._ComplaintToClub != nil {
		return *m._ComplaintToClub, true
	}
	return
}

// ComplaintToClubIDs returns the ComplaintToClub ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ComplaintToClubID instead. It exists only for internal usage by the builders.
func (m *ComplaintMutation) ComplaintToClubIDs() (ids []int) {
	if id := m._ComplaintToClub; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComplaintToClub reset all changes of the "ComplaintToClub" edge.
func (m *ComplaintMutation) ResetComplaintToClub() {
	m._ComplaintToClub = nil
	m.cleared_ComplaintToClub = false
}

// Op returns the operation name.
func (m *ComplaintMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Complaint).
func (m *ComplaintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ComplaintMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.info != nil {
		fields = append(fields, complaint.FieldInfo)
	}
	if m.date != nil {
		fields = append(fields, complaint.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ComplaintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case complaint.FieldInfo:
		return m.Info()
	case complaint.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ComplaintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case complaint.FieldInfo:
		return m.OldInfo(ctx)
	case complaint.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Complaint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComplaintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case complaint.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case complaint.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Complaint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ComplaintMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ComplaintMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComplaintMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Complaint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ComplaintMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ComplaintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComplaintMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Complaint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ComplaintMutation) ResetField(name string) error {
	switch name {
	case complaint.FieldInfo:
		m.ResetInfo()
		return nil
	case complaint.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Complaint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ComplaintMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ComplaintToUser != nil {
		edges = append(edges, complaint.EdgeComplaintToUser)
	}
	if m._ComplaintToComplaintType != nil {
		edges = append(edges, complaint.EdgeComplaintToComplaintType)
	}
	if m._ComplaintToClub != nil {
		edges = append(edges, complaint.EdgeComplaintToClub)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ComplaintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case complaint.EdgeComplaintToUser:
		if id := m._ComplaintToUser; id != nil {
			return []ent.Value{*id}
		}
	case complaint.EdgeComplaintToComplaintType:
		if id := m._ComplaintToComplaintType; id != nil {
			return []ent.Value{*id}
		}
	case complaint.EdgeComplaintToClub:
		if id := m._ComplaintToClub; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ComplaintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ComplaintMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ComplaintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ComplaintToUser {
		edges = append(edges, complaint.EdgeComplaintToUser)
	}
	if m.cleared_ComplaintToComplaintType {
		edges = append(edges, complaint.EdgeComplaintToComplaintType)
	}
	if m.cleared_ComplaintToClub {
		edges = append(edges, complaint.EdgeComplaintToClub)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ComplaintMutation) EdgeCleared(name string) bool {
	switch name {
	case complaint.EdgeComplaintToUser:
		return m.cleared_ComplaintToUser
	case complaint.EdgeComplaintToComplaintType:
		return m.cleared_ComplaintToComplaintType
	case complaint.EdgeComplaintToClub:
		return m.cleared_ComplaintToClub
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ComplaintMutation) ClearEdge(name string) error {
	switch name {
	case complaint.EdgeComplaintToUser:
		m.ClearComplaintToUser()
		return nil
	case complaint.EdgeComplaintToComplaintType:
		m.ClearComplaintToComplaintType()
		return nil
	case complaint.EdgeComplaintToClub:
		m.ClearComplaintToClub()
		return nil
	}
	return fmt.Errorf("unknown Complaint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ComplaintMutation) ResetEdge(name string) error {
	switch name {
	case complaint.EdgeComplaintToUser:
		m.ResetComplaintToUser()
		return nil
	case complaint.EdgeComplaintToComplaintType:
		m.ResetComplaintToComplaintType()
		return nil
	case complaint.EdgeComplaintToClub:
		m.ResetComplaintToClub()
		return nil
	}
	return fmt.Errorf("unknown Complaint edge %s", name)
}

// ComplaintTypeMutation represents an operation that mutate the ComplaintTypes
// nodes in the graph.
type ComplaintTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	description                      *string
	clearedFields                    map[string]struct{}
	_ComplaintTypeToComplaint        map[int]struct{}
	removed_ComplaintTypeToComplaint map[int]struct{}
	done                             bool
	oldValue                         func(context.Context) (*ComplaintType, error)
}

var _ ent.Mutation = (*ComplaintTypeMutation)(nil)

// complainttypeOption allows to manage the mutation configuration using functional options.
type complainttypeOption func(*ComplaintTypeMutation)

// newComplaintTypeMutation creates new mutation for $n.Name.
func newComplaintTypeMutation(c config, op Op, opts ...complainttypeOption) *ComplaintTypeMutation {
	m := &ComplaintTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeComplaintType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComplaintTypeID sets the id field of the mutation.
func withComplaintTypeID(id int) complainttypeOption {
	return func(m *ComplaintTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ComplaintType
		)
		m.oldValue = func(ctx context.Context) (*ComplaintType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ComplaintType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComplaintType sets the old ComplaintType of the mutation.
func withComplaintType(node *ComplaintType) complainttypeOption {
	return func(m *ComplaintTypeMutation) {
		m.oldValue = func(context.Context) (*ComplaintType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComplaintTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComplaintTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ComplaintTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDescription sets the description field.
func (m *ComplaintTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ComplaintTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the ComplaintType.
// If the ComplaintType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComplaintTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *ComplaintTypeMutation) ResetDescription() {
	m.description = nil
}

// AddComplaintTypeToComplaintIDs adds the ComplaintTypeToComplaint edge to Complaint by ids.
func (m *ComplaintTypeMutation) AddComplaintTypeToComplaintIDs(ids ...int) {
	if m._ComplaintTypeToComplaint == nil {
		m._ComplaintTypeToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m._ComplaintTypeToComplaint[ids[i]] = struct{}{}
	}
}

// RemoveComplaintTypeToComplaintIDs removes the ComplaintTypeToComplaint edge to Complaint by ids.
func (m *ComplaintTypeMutation) RemoveComplaintTypeToComplaintIDs(ids ...int) {
	if m.removed_ComplaintTypeToComplaint == nil {
		m.removed_ComplaintTypeToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ComplaintTypeToComplaint[ids[i]] = struct{}{}
	}
}

// RemovedComplaintTypeToComplaint returns the removed ids of ComplaintTypeToComplaint.
func (m *ComplaintTypeMutation) RemovedComplaintTypeToComplaintIDs() (ids []int) {
	for id := range m.removed_ComplaintTypeToComplaint {
		ids = append(ids, id)
	}
	return
}

// ComplaintTypeToComplaintIDs returns the ComplaintTypeToComplaint ids in the mutation.
func (m *ComplaintTypeMutation) ComplaintTypeToComplaintIDs() (ids []int) {
	for id := range m._ComplaintTypeToComplaint {
		ids = append(ids, id)
	}
	return
}

// ResetComplaintTypeToComplaint reset all changes of the "ComplaintTypeToComplaint" edge.
func (m *ComplaintTypeMutation) ResetComplaintTypeToComplaint() {
	m._ComplaintTypeToComplaint = nil
	m.removed_ComplaintTypeToComplaint = nil
}

// Op returns the operation name.
func (m *ComplaintTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ComplaintType).
func (m *ComplaintTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ComplaintTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.description != nil {
		fields = append(fields, complainttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ComplaintTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case complainttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ComplaintTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case complainttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ComplaintType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComplaintTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case complainttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ComplaintType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ComplaintTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ComplaintTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComplaintTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ComplaintType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ComplaintTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ComplaintTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComplaintTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ComplaintType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ComplaintTypeMutation) ResetField(name string) error {
	switch name {
	case complainttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ComplaintType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ComplaintTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ComplaintTypeToComplaint != nil {
		edges = append(edges, complainttype.EdgeComplaintTypeToComplaint)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ComplaintTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case complainttype.EdgeComplaintTypeToComplaint:
		ids := make([]ent.Value, 0, len(m._ComplaintTypeToComplaint))
		for id := range m._ComplaintTypeToComplaint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ComplaintTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_ComplaintTypeToComplaint != nil {
		edges = append(edges, complainttype.EdgeComplaintTypeToComplaint)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ComplaintTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case complainttype.EdgeComplaintTypeToComplaint:
		ids := make([]ent.Value, 0, len(m.removed_ComplaintTypeToComplaint))
		for id := range m.removed_ComplaintTypeToComplaint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ComplaintTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ComplaintTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ComplaintTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ComplaintType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ComplaintTypeMutation) ResetEdge(name string) error {
	switch name {
	case complainttype.EdgeComplaintTypeToComplaint:
		m.ResetComplaintTypeToComplaint()
		return nil
	}
	return fmt.Errorf("unknown ComplaintType edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op              Op
	typ             string
	id              *int
	room_name       *string
	room_location   *string
	room_floor      *string
	max_contain     *int
	addmax_contain  *int
	clearedFields   map[string]struct{}
	roomuses        map[int]struct{}
	removedroomuses map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomName sets the room_name field.
func (m *RoomMutation) SetRoomName(s string) {
	m.room_name = &s
}

// RoomName returns the room_name value in the mutation.
func (m *RoomMutation) RoomName() (r string, exists bool) {
	v := m.room_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomName returns the old room_name value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomName: %w", err)
	}
	return oldValue.RoomName, nil
}

// ResetRoomName reset all changes of the "room_name" field.
func (m *RoomMutation) ResetRoomName() {
	m.room_name = nil
}

// SetRoomLocation sets the room_location field.
func (m *RoomMutation) SetRoomLocation(s string) {
	m.room_location = &s
}

// RoomLocation returns the room_location value in the mutation.
func (m *RoomMutation) RoomLocation() (r string, exists bool) {
	v := m.room_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomLocation returns the old room_location value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRoomLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomLocation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomLocation: %w", err)
	}
	return oldValue.RoomLocation, nil
}

// ResetRoomLocation reset all changes of the "room_location" field.
func (m *RoomMutation) ResetRoomLocation() {
	m.room_location = nil
}

// SetRoomFloor sets the room_floor field.
func (m *RoomMutation) SetRoomFloor(s string) {
	m.room_floor = &s
}

// RoomFloor returns the room_floor value in the mutation.
func (m *RoomMutation) RoomFloor() (r string, exists bool) {
	v := m.room_floor
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomFloor returns the old room_floor value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRoomFloor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomFloor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomFloor: %w", err)
	}
	return oldValue.RoomFloor, nil
}

// ResetRoomFloor reset all changes of the "room_floor" field.
func (m *RoomMutation) ResetRoomFloor() {
	m.room_floor = nil
}

// SetMaxContain sets the max_contain field.
func (m *RoomMutation) SetMaxContain(i int) {
	m.max_contain = &i
	m.addmax_contain = nil
}

// MaxContain returns the max_contain value in the mutation.
func (m *RoomMutation) MaxContain() (r int, exists bool) {
	v := m.max_contain
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxContain returns the old max_contain value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldMaxContain(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxContain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxContain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxContain: %w", err)
	}
	return oldValue.MaxContain, nil
}

// AddMaxContain adds i to max_contain.
func (m *RoomMutation) AddMaxContain(i int) {
	if m.addmax_contain != nil {
		*m.addmax_contain += i
	} else {
		m.addmax_contain = &i
	}
}

// AddedMaxContain returns the value that was added to the max_contain field in this mutation.
func (m *RoomMutation) AddedMaxContain() (r int, exists bool) {
	v := m.addmax_contain
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxContain reset all changes of the "max_contain" field.
func (m *RoomMutation) ResetMaxContain() {
	m.max_contain = nil
	m.addmax_contain = nil
}

// AddRoomuseIDs adds the roomuses edge to Roomuse by ids.
func (m *RoomMutation) AddRoomuseIDs(ids ...int) {
	if m.roomuses == nil {
		m.roomuses = make(map[int]struct{})
	}
	for i := range ids {
		m.roomuses[ids[i]] = struct{}{}
	}
}

// RemoveRoomuseIDs removes the roomuses edge to Roomuse by ids.
func (m *RoomMutation) RemoveRoomuseIDs(ids ...int) {
	if m.removedroomuses == nil {
		m.removedroomuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomuses[ids[i]] = struct{}{}
	}
}

// RemovedRoomuses returns the removed ids of roomuses.
func (m *RoomMutation) RemovedRoomusesIDs() (ids []int) {
	for id := range m.removedroomuses {
		ids = append(ids, id)
	}
	return
}

// RoomusesIDs returns the roomuses ids in the mutation.
func (m *RoomMutation) RoomusesIDs() (ids []int) {
	for id := range m.roomuses {
		ids = append(ids, id)
	}
	return
}

// ResetRoomuses reset all changes of the "roomuses" edge.
func (m *RoomMutation) ResetRoomuses() {
	m.roomuses = nil
	m.removedroomuses = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.room_name != nil {
		fields = append(fields, room.FieldRoomName)
	}
	if m.room_location != nil {
		fields = append(fields, room.FieldRoomLocation)
	}
	if m.room_floor != nil {
		fields = append(fields, room.FieldRoomFloor)
	}
	if m.max_contain != nil {
		fields = append(fields, room.FieldMaxContain)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRoomName:
		return m.RoomName()
	case room.FieldRoomLocation:
		return m.RoomLocation()
	case room.FieldRoomFloor:
		return m.RoomFloor()
	case room.FieldMaxContain:
		return m.MaxContain()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRoomName:
		return m.OldRoomName(ctx)
	case room.FieldRoomLocation:
		return m.OldRoomLocation(ctx)
	case room.FieldRoomFloor:
		return m.OldRoomFloor(ctx)
	case room.FieldMaxContain:
		return m.OldMaxContain(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomName(v)
		return nil
	case room.FieldRoomLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomLocation(v)
		return nil
	case room.FieldRoomFloor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomFloor(v)
		return nil
	case room.FieldMaxContain:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxContain(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	var fields []string
	if m.addmax_contain != nil {
		fields = append(fields, room.FieldMaxContain)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case room.FieldMaxContain:
		return m.AddedMaxContain()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case room.FieldMaxContain:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxContain(v)
		return nil
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRoomName:
		m.ResetRoomName()
		return nil
	case room.FieldRoomLocation:
		m.ResetRoomLocation()
		return nil
	case room.FieldRoomFloor:
		m.ResetRoomFloor()
		return nil
	case room.FieldMaxContain:
		m.ResetMaxContain()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomuses != nil {
		edges = append(edges, room.EdgeRoomuses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomuses:
		ids := make([]ent.Value, 0, len(m.roomuses))
		for id := range m.roomuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomuses != nil {
		edges = append(edges, room.EdgeRoomuses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRoomuses:
		ids := make([]ent.Value, 0, len(m.removedroomuses))
		for id := range m.removedroomuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeRoomuses:
		m.ResetRoomuses()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoompurposeMutation represents an operation that mutate the Roompurposes
// nodes in the graph.
type RoompurposeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	purpose            *string
	clearedFields      map[string]struct{}
	roompurpose        map[int]struct{}
	removedroompurpose map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Roompurpose, error)
}

var _ ent.Mutation = (*RoompurposeMutation)(nil)

// roompurposeOption allows to manage the mutation configuration using functional options.
type roompurposeOption func(*RoompurposeMutation)

// newRoompurposeMutation creates new mutation for $n.Name.
func newRoompurposeMutation(c config, op Op, opts ...roompurposeOption) *RoompurposeMutation {
	m := &RoompurposeMutation{
		config:        c,
		op:            op,
		typ:           TypeRoompurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoompurposeID sets the id field of the mutation.
func withRoompurposeID(id int) roompurposeOption {
	return func(m *RoompurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *Roompurpose
		)
		m.oldValue = func(ctx context.Context) (*Roompurpose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roompurpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoompurpose sets the old Roompurpose of the mutation.
func withRoompurpose(node *Roompurpose) roompurposeOption {
	return func(m *RoompurposeMutation) {
		m.oldValue = func(context.Context) (*Roompurpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoompurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoompurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoompurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPurpose sets the purpose field.
func (m *RoompurposeMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the purpose value in the mutation.
func (m *RoompurposeMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old purpose value of the Roompurpose.
// If the Roompurpose object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoompurposeMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurpose is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose reset all changes of the "purpose" field.
func (m *RoompurposeMutation) ResetPurpose() {
	m.purpose = nil
}

// AddRoompurposeIDs adds the roompurpose edge to Roomuse by ids.
func (m *RoompurposeMutation) AddRoompurposeIDs(ids ...int) {
	if m.roompurpose == nil {
		m.roompurpose = make(map[int]struct{})
	}
	for i := range ids {
		m.roompurpose[ids[i]] = struct{}{}
	}
}

// RemoveRoompurposeIDs removes the roompurpose edge to Roomuse by ids.
func (m *RoompurposeMutation) RemoveRoompurposeIDs(ids ...int) {
	if m.removedroompurpose == nil {
		m.removedroompurpose = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroompurpose[ids[i]] = struct{}{}
	}
}

// RemovedRoompurpose returns the removed ids of roompurpose.
func (m *RoompurposeMutation) RemovedRoompurposeIDs() (ids []int) {
	for id := range m.removedroompurpose {
		ids = append(ids, id)
	}
	return
}

// RoompurposeIDs returns the roompurpose ids in the mutation.
func (m *RoompurposeMutation) RoompurposeIDs() (ids []int) {
	for id := range m.roompurpose {
		ids = append(ids, id)
	}
	return
}

// ResetRoompurpose reset all changes of the "roompurpose" edge.
func (m *RoompurposeMutation) ResetRoompurpose() {
	m.roompurpose = nil
	m.removedroompurpose = nil
}

// Op returns the operation name.
func (m *RoompurposeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roompurpose).
func (m *RoompurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoompurposeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.purpose != nil {
		fields = append(fields, roompurpose.FieldPurpose)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoompurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roompurpose.FieldPurpose:
		return m.Purpose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoompurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roompurpose.FieldPurpose:
		return m.OldPurpose(ctx)
	}
	return nil, fmt.Errorf("unknown Roompurpose field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoompurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roompurpose.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	}
	return fmt.Errorf("unknown Roompurpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoompurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoompurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoompurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Roompurpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoompurposeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoompurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoompurposeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roompurpose nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoompurposeMutation) ResetField(name string) error {
	switch name {
	case roompurpose.FieldPurpose:
		m.ResetPurpose()
		return nil
	}
	return fmt.Errorf("unknown Roompurpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoompurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roompurpose != nil {
		edges = append(edges, roompurpose.EdgeRoompurpose)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoompurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roompurpose.EdgeRoompurpose:
		ids := make([]ent.Value, 0, len(m.roompurpose))
		for id := range m.roompurpose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoompurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroompurpose != nil {
		edges = append(edges, roompurpose.EdgeRoompurpose)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoompurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roompurpose.EdgeRoompurpose:
		ids := make([]ent.Value, 0, len(m.removedroompurpose))
		for id := range m.removedroompurpose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoompurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoompurposeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoompurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Roompurpose unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoompurposeMutation) ResetEdge(name string) error {
	switch name {
	case roompurpose.EdgeRoompurpose:
		m.ResetRoompurpose()
		return nil
	}
	return fmt.Errorf("unknown Roompurpose edge %s", name)
}

// RoomuseMutation represents an operation that mutate the Roomuses
// nodes in the graph.
type RoomuseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	added_time      *time.Time
	clearedFields   map[string]struct{}
	rooms           *int
	clearedrooms    bool
	purposes        *int
	clearedpurposes bool
	users           *int
	clearedusers    bool
	done            bool
	oldValue        func(context.Context) (*Roomuse, error)
}

var _ ent.Mutation = (*RoomuseMutation)(nil)

// roomuseOption allows to manage the mutation configuration using functional options.
type roomuseOption func(*RoomuseMutation)

// newRoomuseMutation creates new mutation for $n.Name.
func newRoomuseMutation(c config, op Op, opts ...roomuseOption) *RoomuseMutation {
	m := &RoomuseMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomuse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomuseID sets the id field of the mutation.
func withRoomuseID(id int) roomuseOption {
	return func(m *RoomuseMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomuse
		)
		m.oldValue = func(ctx context.Context) (*Roomuse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomuse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomuse sets the old Roomuse of the mutation.
func withRoomuse(node *Roomuse) roomuseOption {
	return func(m *RoomuseMutation) {
		m.oldValue = func(context.Context) (*Roomuse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomuseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomuseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomuseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedTime sets the added_time field.
func (m *RoomuseMutation) SetAddedTime(t time.Time) {
	m.added_time = &t
}

// AddedTime returns the added_time value in the mutation.
func (m *RoomuseMutation) AddedTime() (r time.Time, exists bool) {
	v := m.added_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old added_time value of the Roomuse.
// If the Roomuse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomuseMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime reset all changes of the "added_time" field.
func (m *RoomuseMutation) ResetAddedTime() {
	m.added_time = nil
}

// SetRoomsID sets the rooms edge to Room by id.
func (m *RoomuseMutation) SetRoomsID(id int) {
	m.rooms = &id
}

// ClearRooms clears the rooms edge to Room.
func (m *RoomuseMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared returns if the edge rooms was cleared.
func (m *RoomuseMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RoomsID returns the rooms id in the mutation.
func (m *RoomuseMutation) RoomsID() (id int, exists bool) {
	if m.rooms != nil {
		return *m.rooms, true
	}
	return
}

// RoomsIDs returns the rooms ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomsID instead. It exists only for internal usage by the builders.
func (m *RoomuseMutation) RoomsIDs() (ids []int) {
	if id := m.rooms; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRooms reset all changes of the "rooms" edge.
func (m *RoomuseMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
}

// SetPurposesID sets the purposes edge to Roompurpose by id.
func (m *RoomuseMutation) SetPurposesID(id int) {
	m.purposes = &id
}

// ClearPurposes clears the purposes edge to Roompurpose.
func (m *RoomuseMutation) ClearPurposes() {
	m.clearedpurposes = true
}

// PurposesCleared returns if the edge purposes was cleared.
func (m *RoomuseMutation) PurposesCleared() bool {
	return m.clearedpurposes
}

// PurposesID returns the purposes id in the mutation.
func (m *RoomuseMutation) PurposesID() (id int, exists bool) {
	if m.purposes != nil {
		return *m.purposes, true
	}
	return
}

// PurposesIDs returns the purposes ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PurposesID instead. It exists only for internal usage by the builders.
func (m *RoomuseMutation) PurposesIDs() (ids []int) {
	if id := m.purposes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPurposes reset all changes of the "purposes" edge.
func (m *RoomuseMutation) ResetPurposes() {
	m.purposes = nil
	m.clearedpurposes = false
}

// SetUsersID sets the users edge to User by id.
func (m *RoomuseMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the users edge to User.
func (m *RoomuseMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared returns if the edge users was cleared.
func (m *RoomuseMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the users id in the mutation.
func (m *RoomuseMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the users ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *RoomuseMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *RoomuseMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Op returns the operation name.
func (m *RoomuseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomuse).
func (m *RoomuseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomuseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.added_time != nil {
		fields = append(fields, roomuse.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomuseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomuse.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomuseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomuse.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Roomuse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomuseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomuse.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Roomuse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomuseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomuseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomuseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomuse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomuseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomuseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomuseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomuse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomuseMutation) ResetField(name string) error {
	switch name {
	case roomuse.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Roomuse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomuseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rooms != nil {
		edges = append(edges, roomuse.EdgeRooms)
	}
	if m.purposes != nil {
		edges = append(edges, roomuse.EdgePurposes)
	}
	if m.users != nil {
		edges = append(edges, roomuse.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomuseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomuse.EdgeRooms:
		if id := m.rooms; id != nil {
			return []ent.Value{*id}
		}
	case roomuse.EdgePurposes:
		if id := m.purposes; id != nil {
			return []ent.Value{*id}
		}
	case roomuse.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomuseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomuseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomuseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrooms {
		edges = append(edges, roomuse.EdgeRooms)
	}
	if m.clearedpurposes {
		edges = append(edges, roomuse.EdgePurposes)
	}
	if m.clearedusers {
		edges = append(edges, roomuse.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomuseMutation) EdgeCleared(name string) bool {
	switch name {
	case roomuse.EdgeRooms:
		return m.clearedrooms
	case roomuse.EdgePurposes:
		return m.clearedpurposes
	case roomuse.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomuseMutation) ClearEdge(name string) error {
	switch name {
	case roomuse.EdgeRooms:
		m.ClearRooms()
		return nil
	case roomuse.EdgePurposes:
		m.ClearPurposes()
		return nil
	case roomuse.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Roomuse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomuseMutation) ResetEdge(name string) error {
	switch name {
	case roomuse.EdgeRooms:
		m.ResetRooms()
		return nil
	case roomuse.EdgePurposes:
		m.ResetPurposes()
		return nil
	case roomuse.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Roomuse edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	email                   *string
	password                *int
	addpassword             *int
	clearedFields           map[string]struct{}
	usertype                *int
	clearedusertype         bool
	club                    map[int]struct{}
	removedclub             map[int]struct{}
	activities              map[int]struct{}
	removedactivities       map[int]struct{}
	clubapplication         map[int]struct{}
	removedclubapplication  map[int]struct{}
	_UserToComplaint        map[int]struct{}
	removed_UserToComplaint map[int]struct{}
	_Roomuse                map[int]struct{}
	removed_Roomuse         map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(i int) {
	m.password = &i
	m.addpassword = nil
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r int, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// AddPassword adds i to password.
func (m *UserMutation) AddPassword(i int) {
	if m.addpassword != nil {
		*m.addpassword += i
	} else {
		m.addpassword = &i
	}
}

// AddedPassword returns the value that was added to the password field in this mutation.
func (m *UserMutation) AddedPassword() (r int, exists bool) {
	v := m.addpassword
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	m.addpassword = nil
}

// SetUsertypeID sets the usertype edge to Usertype by id.
func (m *UserMutation) SetUsertypeID(id int) {
	m.usertype = &id
}

// ClearUsertype clears the usertype edge to Usertype.
func (m *UserMutation) ClearUsertype() {
	m.clearedusertype = true
}

// UsertypeCleared returns if the edge usertype was cleared.
func (m *UserMutation) UsertypeCleared() bool {
	return m.clearedusertype
}

// UsertypeID returns the usertype id in the mutation.
func (m *UserMutation) UsertypeID() (id int, exists bool) {
	if m.usertype != nil {
		return *m.usertype, true
	}
	return
}

// UsertypeIDs returns the usertype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsertypeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UsertypeIDs() (ids []int) {
	if id := m.usertype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsertype reset all changes of the "usertype" edge.
func (m *UserMutation) ResetUsertype() {
	m.usertype = nil
	m.clearedusertype = false
}

// AddClubIDs adds the club edge to Club by ids.
func (m *UserMutation) AddClubIDs(ids ...int) {
	if m.club == nil {
		m.club = make(map[int]struct{})
	}
	for i := range ids {
		m.club[ids[i]] = struct{}{}
	}
}

// RemoveClubIDs removes the club edge to Club by ids.
func (m *UserMutation) RemoveClubIDs(ids ...int) {
	if m.removedclub == nil {
		m.removedclub = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclub[ids[i]] = struct{}{}
	}
}

// RemovedClub returns the removed ids of club.
func (m *UserMutation) RemovedClubIDs() (ids []int) {
	for id := range m.removedclub {
		ids = append(ids, id)
	}
	return
}

// ClubIDs returns the club ids in the mutation.
func (m *UserMutation) ClubIDs() (ids []int) {
	for id := range m.club {
		ids = append(ids, id)
	}
	return
}

// ResetClub reset all changes of the "club" edge.
func (m *UserMutation) ResetClub() {
	m.club = nil
	m.removedclub = nil
}

// AddActivityIDs adds the activities edge to Activities by ids.
func (m *UserMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// RemoveActivityIDs removes the activities edge to Activities by ids.
func (m *UserMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed ids of activities.
func (m *UserMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the activities ids in the mutation.
func (m *UserMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities reset all changes of the "activities" edge.
func (m *UserMutation) ResetActivities() {
	m.activities = nil
	m.removedactivities = nil
}

// AddClubapplicationIDs adds the clubapplication edge to Clubapplication by ids.
func (m *UserMutation) AddClubapplicationIDs(ids ...int) {
	if m.clubapplication == nil {
		m.clubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.clubapplication[ids[i]] = struct{}{}
	}
}

// RemoveClubapplicationIDs removes the clubapplication edge to Clubapplication by ids.
func (m *UserMutation) RemoveClubapplicationIDs(ids ...int) {
	if m.removedclubapplication == nil {
		m.removedclubapplication = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclubapplication[ids[i]] = struct{}{}
	}
}

// RemovedClubapplication returns the removed ids of clubapplication.
func (m *UserMutation) RemovedClubapplicationIDs() (ids []int) {
	for id := range m.removedclubapplication {
		ids = append(ids, id)
	}
	return
}

// ClubapplicationIDs returns the clubapplication ids in the mutation.
func (m *UserMutation) ClubapplicationIDs() (ids []int) {
	for id := range m.clubapplication {
		ids = append(ids, id)
	}
	return
}

// ResetClubapplication reset all changes of the "clubapplication" edge.
func (m *UserMutation) ResetClubapplication() {
	m.clubapplication = nil
	m.removedclubapplication = nil
}

// AddUserToComplaintIDs adds the UserToComplaint edge to Complaint by ids.
func (m *UserMutation) AddUserToComplaintIDs(ids ...int) {
	if m._UserToComplaint == nil {
		m._UserToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m._UserToComplaint[ids[i]] = struct{}{}
	}
}

// RemoveUserToComplaintIDs removes the UserToComplaint edge to Complaint by ids.
func (m *UserMutation) RemoveUserToComplaintIDs(ids ...int) {
	if m.removed_UserToComplaint == nil {
		m.removed_UserToComplaint = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_UserToComplaint[ids[i]] = struct{}{}
	}
}

// RemovedUserToComplaint returns the removed ids of UserToComplaint.
func (m *UserMutation) RemovedUserToComplaintIDs() (ids []int) {
	for id := range m.removed_UserToComplaint {
		ids = append(ids, id)
	}
	return
}

// UserToComplaintIDs returns the UserToComplaint ids in the mutation.
func (m *UserMutation) UserToComplaintIDs() (ids []int) {
	for id := range m._UserToComplaint {
		ids = append(ids, id)
	}
	return
}

// ResetUserToComplaint reset all changes of the "UserToComplaint" edge.
func (m *UserMutation) ResetUserToComplaint() {
	m._UserToComplaint = nil
	m.removed_UserToComplaint = nil
}

// AddRoomuseIDs adds the Roomuse edge to Roomuse by ids.
func (m *UserMutation) AddRoomuseIDs(ids ...int) {
	if m._Roomuse == nil {
		m._Roomuse = make(map[int]struct{})
	}
	for i := range ids {
		m._Roomuse[ids[i]] = struct{}{}
	}
}

// RemoveRoomuseIDs removes the Roomuse edge to Roomuse by ids.
func (m *UserMutation) RemoveRoomuseIDs(ids ...int) {
	if m.removed_Roomuse == nil {
		m.removed_Roomuse = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Roomuse[ids[i]] = struct{}{}
	}
}

// RemovedRoomuse returns the removed ids of Roomuse.
func (m *UserMutation) RemovedRoomuseIDs() (ids []int) {
	for id := range m.removed_Roomuse {
		ids = append(ids, id)
	}
	return
}

// RoomuseIDs returns the Roomuse ids in the mutation.
func (m *UserMutation) RoomuseIDs() (ids []int) {
	for id := range m._Roomuse {
		ids = append(ids, id)
	}
	return
}

// ResetRoomuse reset all changes of the "Roomuse" edge.
func (m *UserMutation) ResetRoomuse() {
	m._Roomuse = nil
	m.removed_Roomuse = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addpassword != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPassword:
		return m.AddedPassword()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPassword:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.usertype != nil {
		edges = append(edges, user.EdgeUsertype)
	}
	if m.club != nil {
		edges = append(edges, user.EdgeClub)
	}
	if m.activities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.clubapplication != nil {
		edges = append(edges, user.EdgeClubapplication)
	}
	if m._UserToComplaint != nil {
		edges = append(edges, user.EdgeUserToComplaint)
	}
	if m._Roomuse != nil {
		edges = append(edges, user.EdgeRoomuse)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUsertype:
		if id := m.usertype; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeClub:
		ids := make([]ent.Value, 0, len(m.club))
		for id := range m.club {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.clubapplication))
		for id := range m.clubapplication {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToComplaint:
		ids := make([]ent.Value, 0, len(m._UserToComplaint))
		for id := range m._UserToComplaint {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoomuse:
		ids := make([]ent.Value, 0, len(m._Roomuse))
		for id := range m._Roomuse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedclub != nil {
		edges = append(edges, user.EdgeClub)
	}
	if m.removedactivities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.removedclubapplication != nil {
		edges = append(edges, user.EdgeClubapplication)
	}
	if m.removed_UserToComplaint != nil {
		edges = append(edges, user.EdgeUserToComplaint)
	}
	if m.removed_Roomuse != nil {
		edges = append(edges, user.EdgeRoomuse)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeClub:
		ids := make([]ent.Value, 0, len(m.removedclub))
		for id := range m.removedclub {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubapplication:
		ids := make([]ent.Value, 0, len(m.removedclubapplication))
		for id := range m.removedclubapplication {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToComplaint:
		ids := make([]ent.Value, 0, len(m.removed_UserToComplaint))
		for id := range m.removed_UserToComplaint {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoomuse:
		ids := make([]ent.Value, 0, len(m.removed_Roomuse))
		for id := range m.removed_Roomuse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedusertype {
		edges = append(edges, user.EdgeUsertype)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUsertype:
		return m.clearedusertype
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUsertype:
		m.ClearUsertype()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUsertype:
		m.ResetUsertype()
		return nil
	case user.EdgeClub:
		m.ResetClub()
		return nil
	case user.EdgeActivities:
		m.ResetActivities()
		return nil
	case user.EdgeClubapplication:
		m.ResetClubapplication()
		return nil
	case user.EdgeUserToComplaint:
		m.ResetUserToComplaint()
		return nil
	case user.EdgeRoomuse:
		m.ResetRoomuse()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UsertypeMutation represents an operation that mutate the Usertypes
// nodes in the graph.
type UsertypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Usertype, error)
}

var _ ent.Mutation = (*UsertypeMutation)(nil)

// usertypeOption allows to manage the mutation configuration using functional options.
type usertypeOption func(*UsertypeMutation)

// newUsertypeMutation creates new mutation for $n.Name.
func newUsertypeMutation(c config, op Op, opts ...usertypeOption) *UsertypeMutation {
	m := &UsertypeMutation{
		config:        c,
		op:            op,
		typ:           TypeUsertype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsertypeID sets the id field of the mutation.
func withUsertypeID(id int) usertypeOption {
	return func(m *UsertypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Usertype
		)
		m.oldValue = func(ctx context.Context) (*Usertype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Usertype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsertype sets the old Usertype of the mutation.
func withUsertype(node *Usertype) usertypeOption {
	return func(m *UsertypeMutation) {
		m.oldValue = func(context.Context) (*Usertype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsertypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsertypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UsertypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UsertypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UsertypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Usertype.
// If the Usertype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsertypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UsertypeMutation) ResetName() {
	m.name = nil
}

// AddUserIDs adds the user edge to User by ids.
func (m *UsertypeMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *UsertypeMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *UsertypeMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *UsertypeMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *UsertypeMutation) ResetUser() {
	m.user = nil
	m.removeduser = nil
}

// Op returns the operation name.
func (m *UsertypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Usertype).
func (m *UsertypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UsertypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, usertype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UsertypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UsertypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Usertype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UsertypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Usertype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UsertypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UsertypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UsertypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Usertype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UsertypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UsertypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsertypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Usertype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UsertypeMutation) ResetField(name string) error {
	switch name {
	case usertype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Usertype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UsertypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usertype.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UsertypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertype.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UsertypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser != nil {
		edges = append(edges, usertype.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UsertypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usertype.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UsertypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UsertypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UsertypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Usertype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UsertypeMutation) ResetEdge(name string) error {
	switch name {
	case usertype.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Usertype edge %s", name)
}
